<!DOCTYPE html>
<!-- saved from url=(0065)https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/ -->
<html lang="en-US" data-theme="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><link rel="shortcut icon" href="https://khale.github.io/iit-cs562-s24-site/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="./Project 2 _ CS 562_files/just-the-docs-default.css"> <script type="text/javascript" src="./Project 2 _ CS 562_files/lunr.min.js"></script> <script type="text/javascript" src="./Project 2 _ CS 562_files/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>Project 2 | CS 562</title><meta name="generator" content="Jekyll v3.9.5"><meta property="og:title" content="Project 2"><meta name="author" content="Kyle Hale"><meta property="og:locale" content="en_US"><meta name="description" content="Into the Depths of Virtualization and Virtual Machines"><meta property="og:description" content="Into the Depths of Virtualization and Virtual Machines"><link rel="canonical" href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/"><meta property="og:url" content="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/"><meta property="og:site_name" content="CS 562"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><meta property="twitter:title" content="Project 2"> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Kyle Hale"},"description":"Into the Depths of Virtualization and Virtual Machines","headline":"Project 2","url":"https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/"}</script><style type="text/css">iframe#teal-job-tracker-iframe-stable {
    min-width: 380px !important;
    width: 380px !important;
    min-height: 100vh !important;
    height: 100vh !important;
  }

  @media print {
    #teal-job-tracker-root-stable, #teal-job-tracker-companion-root-stable {
      display: none !important;
    }
  }</style></head><body data-new-gr-c-s-check-loaded="14.1190.0" data-gr-ext-installed=""> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"><title>Search</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"><title>Document</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <script type="text/javascript" src="./Project 2 _ CS 562_files/toggle_init.js"></script><div class="side-bar"><div class="site-header"> <a href="https://khale.github.io/iit-cs562-s24-site/" class="site-title lh-tight"> CS 562 </a> <a href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/calendar/" class="nav-list-link">Course Calendar</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/assets/notes/emu/" class="nav-list-link">Emulation</a></li><li class="nav-list-item active"><a href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://khale.github.io/iit-cs562-s24-site/projects/" class="nav-list-link active">Projects</a><ul class="nav-list"><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/01-6502-prelim/" class="nav-list-link">Project 1 Prelim</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/02-6502/" class="nav-list-link">Project 1</a></li><li class="nav-list-item active"><a href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/" class="nav-list-link active">Project 2</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/04-micro-vmm/" class="nav-list-link">Project 3</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/05-hawker/" class="nav-list-link">Project 4</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/projects/06-research/" class="nav-list-link">Project X</a></li></ul></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/schedule/" class="nav-list-link">Schedule</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/staff/" class="nav-list-link">Staff</a></li><li class="nav-list-item"><a href="https://khale.github.io/iit-cs562-s24-site/about/" class="nav-list-link">Syllabus</a></li></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div class="search"><div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search CS 562" aria-label="Search CS 562" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label></div><div id="search-results" class="search-results"></div></div><nav aria-label="Auxiliary" class="aux-nav"><ul class="aux-nav-list"><li class="aux-nav-list-item"> <a href="https://halek.co/" class="site-button"> Kyle C. Hale </a></li></ul></nav></div><div id="main-content-wrap" class="main-content-wrap"><nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"> <a href="https://khale.github.io/iit-cs562-s24-site/projects/">Projects</a></li><li class="breadcrumb-nav-list-item"> <span>Project 2</span></li></ol></nav><div id="main-content" class="main-content" role="main"><h1 id="project-2-the-hawkbeans-jvm">Project 2: The Hawkbeans JVM</h1><p>Released: Monday, 02/12/2024 <strong>Due Date: Friday, 03/08/2024 11:59PM CST</strong></p><h2 id="overview">Overview</h2><p>For this project, you will be completing the implementation of the Hawkbeans Java Virtual Machine. Namely, you will be completing this project in four parts by implementing components of the JVM that deal with:</p><ol><li>Symbolic Resolution (linking)</li><li>Bytecode Interpretation</li><li>Exceptions</li><li>Garbage Collection</li></ol><p>You will be working with the Hawkbeans codebase, a small implementation of a reasonable subset of the JVM specification. You will receive the code in skeleton form, which you will complete by filling in missing functionality that will allow you to run simple Java programs.</p><p>The goals of this project are to:</p><ul><li>Give you more experience working with a fairly large C source tree</li><li>Understand generally how the Java language works under the hood</li><li>Understand how HLL features like polymorphism, object orientation, automatic memory management, exceptions, protection, threads, and native methods are implemented</li><li>Understand the benefits of stack machine architectures</li><li>Become acquainted with the Java VM specification</li><li>Have fun!</li></ul><p>While working on Hawkbeans, you will no doubt notice many similarities in the code structure to the 6502 emulator you previously completed. You should leverage the wisdom you gained from that project when making design decisions for this one. You will also identify some major differences; some coding tasks here are more open-ended than others, so you will need to think creatively.</p><h2 id="hawkbeans-overview">Hawkbeans Overview</h2><p>Hawkbeans is a small, fairly limited JVM written by your instructor. At this point, simple Java programs will run, but anything involving significant Java runtime support or double-precision floating point math will likely not work. This is partly by design; this JVM will eventually be ported to the Hawknest 6502v emulator, which you previously completed. Below is a list of features <em>not</em> currently supported by this JVM:</p><ul><li>Reflection</li><li>Native library loading (for JNI)</li><li>Multi-threading</li><li>JIT compilation</li><li>Complex exceptions</li><li>Protection and access controls (e.g., private vs. public accessors not enforced)</li><li>Complete type checking</li><li>User-defined class loaders</li><li>Higher-order functions</li></ul><p>That said, it is complete enough to give you a good understanding of how Java works under the hood once you finish writing the missing components.</p><h2 id="part-1-getting-started">Part 1: Getting Started</h2><p>You will first need to download the Hawkbeans skeleton code. As in the first project, you’ll really want to be working on a Linux box or VM. First clone the skeleton code:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/khale/hawkbeans-skeleton.git
</code></pre></div></div><p>This will fetch the code from a public git repo.</p><p>Before you build the code, you’ll need some packages. You can either use Vagrant with the provided <code class="language-plaintext highlighter-rouge">Vagrantfile</code> to run this in a VM, or you can install the packages manually on you own Linux VM. <strong>Windows/Mac are not supported!</strong> These are the packages you’ll need (with Fedora package names):</p><ul><li><code class="language-plaintext highlighter-rouge">python3</code></li><li><code class="language-plaintext highlighter-rouge">python3-pip</code></li><li><code class="language-plaintext highlighter-rouge">readline-devel</code></li><li><code class="language-plaintext highlighter-rouge">java-1.8.0-openjdk</code></li><li><code class="language-plaintext highlighter-rouge">java-1.8.0-openjdk-devel</code></li><li><code class="language-plaintext highlighter-rouge">java-1.8.0-openjdk-javadoc</code></li><li><code class="language-plaintext highlighter-rouge">ant</code></li></ul><h2 id="part-2-building-and-running-hawkbeans">Part 2: Building and Running Hawkbeans</h2><p>You can now build Hawkbeans using <code class="language-plaintext highlighter-rouge">make</code>. This builds the actual JVM. You will also want to build the Java standard libraries which Hawkbeans will use for runtime support. These standard libraries have been borrowed from the TinyVM project:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make jlibs
</code></pre></div></div><p>This will create two new directories, <code class="language-plaintext highlighter-rouge">hblib</code> and <code class="language-plaintext highlighter-rouge">java</code>, both of which contain several class files. You shouldn’t worry about how these are used for now.</p><p>The skeleton code you’re given will compile and run, but will not successfully run a Java program yet. Your job is to get it to that point. In order to do that, you’ll need to implement some major missing functionality.</p><p>To see how to use Hawkbeans, you can run it with the <code class="language-plaintext highlighter-rouge">-h</code> option, or without any arguments. In general, you should invoke it like this:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bin/hawkbeans-clang-debug SomeClassFile
</code></pre></div></div><p>This is exactly the same way you run Java programs using the <code class="language-plaintext highlighter-rouge">java</code> command. There are a few options that are worth mentioning in more detail. The <code class="language-plaintext highlighter-rouge">--heap-size</code> or <code class="language-plaintext highlighter-rouge">-H</code> option will allow you to set the JVM’s heap size manually. The default heap size is 1MB, which is pretty small. You may need to change this when you’re testing your garbage collector later on. The <code class="language-plaintext highlighter-rouge">--trace-gc</code> or <code class="language-plaintext highlighter-rouge">-t</code> option allows you to see stats gathered by the garbage collector, i.e., how many objects were collected, how much heap space was recovered, how long GC took etc. By default, the GC will collect garbage every 20ms. You can change this manually by providing a number in ms using the <code class="language-plaintext highlighter-rouge">--gc-interval</code> or <code class="language-plaintext highlighter-rouge">-c</code> options. The <code class="language-plaintext highlighter-rouge">-i</code> option performs like it did with Hawknest, see the <a href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/#testing-and-debugging">Debugging</a> section for more details.</p><h2 id="part-3-symbolic-resolution-linking">Part 3: Symbolic Resolution (Linking)</h2><p>Java <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">class files</a> are laid out in a well-structured format which makes them relatively easy to parse. A major component of any JVM is a linker/loader component which loads these class files into memory, parses them, and creates internal representations of the data they encode. Every reference to a constant value, a class, or a method in a Java program is encoded in the class file <em>symbolically</em> by the Java compiler. Essentially this means that each such reference consists of a <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">pointer to a descriptor</a> which gives enough information on how to resolve it. As an example, a method reference will simply be encoded as a number which is to be interpreted as an offset into the constant pool. A look up to that constant pool entry will discover a pointer to a descriptor that has more such constant pool offsets. One will be an offset to a String descriptor which contains the bytes for the UTF-8 encoded method name, and the other will be an offset to another String descriptor which describes the method’s parameters and return value using a <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3">character-based encoding</a>. One thing to note is that this is an analog to how dynamic linking is done for traditional compiled programs.</p><p>There are two approaches for resolving these symbolic references. We can either resolve them <em>eagerly</em> when we load and parse the class, or we can resolve them <em>lazily</em>, i.e., not until they’re used. The former method will require more work up front, and has the drawback that classes that aren’t actually used may be loaded into memory. The latter is our technique of choice. That is, we will resolve these references the first time they’re actually used. This means that the various instructions that rely on symbolic references (e.g. <code class="language-plaintext highlighter-rouge">new</code>, <code class="language-plaintext highlighter-rouge">getfield</code>, etc.) will not work correctly until symbolic resolution is complete.</p><h3 id="coding-task-1">Coding Task 1</h3><p>Your first task is to complete method and class resolution in Hawkbeans. This will involve filling in the implementations for two functions in <code class="language-plaintext highlighter-rouge">jvm/class.c</code>, <code class="language-plaintext highlighter-rouge">hb_resolve_class</code> and <code class="language-plaintext highlighter-rouge">hb_resolve_method</code>. The latter relies on the former, so start with <code class="language-plaintext highlighter-rouge">hb_resolve_class</code>. You’ll want to use the Oracle JVM docs for <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.1">class resolution</a> and <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3">method resolution</a> as references when writing your implementation.</p><p>In general, when a constant pool entry is resolved, the implementer of the JVM is given flexibility on what this means in practice. For our purposes, the pointer to the constant info structure (whether it be for a class, a method, a field, etc.) is replaced with an internal pointer to a structure representing the appropriate entry. To indicate that the entry is resolved, we <a href="https://en.wikipedia.org/wiki/X86-64#Canonical_form_addresses">rely on some insider information</a> about virtual addresses and set the highest bit of the pointer’s address to 1 (sometimes this is called a <em>tagged</em> pointer. For example, for classes, this means that a <code class="language-plaintext highlighter-rouge">CONST_Class_info_t*</code> is replaced with a <code class="language-plaintext highlighter-rouge">java_class_t*</code>. For methods, it means a <code class="language-plaintext highlighter-rouge">CONST_Methodref_info_t*</code> is replaced with a <code class="language-plaintext highlighter-rouge">method_info_t*</code> (both structs are defined in <code class="language-plaintext highlighter-rouge">include/class.h</code>).</p><h4 id="hb_resolve_class"><code class="language-plaintext highlighter-rouge">hb_resolve_class()</code></h4><p>This function is used by other parts of the JVM to resolve symbolic references to classes, for example to access their fields or methods. It relies on an existing class loader (there is currently only one, in <code class="language-plaintext highlighter-rouge">jvm/arch/x64-linux/bootstrap_loader.c</code>). The goal here is to transform a constant pool entry (a pointer to a descriptor) into a pointer to our internal representation of classes (see the definition of <code class="language-plaintext highlighter-rouge">java_class_t</code> in <code class="language-plaintext highlighter-rouge">include/class.h</code>).</p><p>Note that this function takes two arguments, an index into the constant pool and a pointer to the source class. This pointer should correspond to the currently used class, i.e., the one that was specified at the command line. Your code should do the following:</p><ul><li>Check if the given index is 0. This is a special case. See the documentation.</li><li>If not, you should derive a pointer to a <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1"><code class="language-plaintext highlighter-rouge">CONSTANT_Class_info_t</code></a> struct, which is defined in <code class="language-plaintext highlighter-rouge">include/constants.h</code>.</li><li>Check if the constant pool entry has been resolved already (using the <code class="language-plaintext highlighter-rouge">IS_RESOLVED()</code>, <code class="language-plaintext highlighter-rouge">MASK_RESOLVED_BIT()</code>, and <code class="language-plaintext highlighter-rouge">MARK_RESOLVED()</code> macros). If it’s already resolved, you should mask off the high-order bit and return the class pointer directly.</li><li>If it hasn’t been resolved, you need to resolve it. First you should check the class map (using the class name). You can derive the class name using the provided <code class="language-plaintext highlighter-rouge">hb_get_const_str()</code> function. You can lookup in the classmap using <code class="language-plaintext highlighter-rouge">hb_get_class()</code>.</li><li>If the class is in the class map, it should be returned and the constant pool entry should be replaced with a pointer to it (with the high order bit set!).</li><li>If it’s not been loaded, you need to invoke the class loader using the class name, add the class to the class map, <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.2">prep the class</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5">initialize the class</a>, and overwrite the constant pool entry appropriately. You’ll want to use <code class="language-plaintext highlighter-rouge">hb_add_class()</code>, <code class="language-plaintext highlighter-rouge">hb_prep_class()</code>, and <code class="language-plaintext highlighter-rouge">hb_init_class()</code>, all defined in <code class="language-plaintext highlighter-rouge">include/class.h</code>.</li></ul><h4 id="hb_resolve_method"><code class="language-plaintext highlighter-rouge">hb_resolve_method()</code></h4><p>Method resolution is slightly more subtle, as what we are doing here is implementing the machinery to support polymorphism! We cannot simply resolve a method by just its name. We also have to consider on which Object it was invoked and its method <em>signature</em>, i.e., the number and types of its arguments. This is why a descriptor for a method (<code class="language-plaintext highlighter-rouge">lCONSTANT_Methodref_info_t</code>) contains two constant pool offsets, one for the name of the method, and another for its signature.</p><p>The general flow of this function is that we should first look and see which class the method in the method descriptor (determined by its <code class="language-plaintext highlighter-rouge">class_idx</code>) belongs to. This class may or may not need to be resolved, hence the order of implementation. Once it is resolved, we iterate through each method descriptor of that class and try to match it to the descriptor given to us (namely, do both the method name and method parameter descriptor match?). If so, we’re done, and we set the constant pool entry to resolved and return the <code class="language-plaintext highlighter-rouge">method_info_t*</code>. Otherwise, we cannot just fail. We now must search up the class hierarchy to see if the method is implemented by this class’s superclasses. This should give you a hint about the algorithmic technique you choose.</p><p>Note that this method adds an extra argument, the <code class="language-plaintext highlighter-rouge">target_cls</code> argument. This should help with the above hint. The initial call to <code class="language-plaintext highlighter-rouge">hb_resolve_method()</code> should provide <code class="language-plaintext highlighter-rouge">NULL</code> for this argument. If it is not, it means we’ve failed the initial search on the method’s attached class, and we’re now trying to trace back through its superclasses.</p><p>Note, you can follow the instructions <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3">here</a>, but you don’t need to worry about implementing access permissions or exceptions. You really only need to implement the steps outlined in point (2).</p><h2 id="part-4-bytecode-interpretation">Part 4: Bytecode Interpretation</h2><p>A significant component of any JVM (or any other VM architecture which implements a virtual ISA for that matter) is an interpreter, in this case a Java bytecode interpreter. The purpose of this component of the JVM is to decode instructions based on their opcode, and dispatch handler functions for each opcode. This should sound very familiar to you after writing your 6502 emulator. One major difference here is that your instruction handlers will need to interact much more closely with other parts of the JVM (namely, class loading, resolution, memory management, exception throwing, etc.). Another is that because the JVM is a stack machine, you do not have to deal with registers, making interpretation somewhat easier.</p><p>A significant portion of the bytecode interpreter is provided for you. You can find this implementation in <code class="language-plaintext highlighter-rouge">jvm/bc_interp.c</code>. Note that interpretation is only done within the context of a method! That is, there is no way to execute bytecode in this JVM without invoking a Java method. This is a very important distinction from other types of virtual machines.</p><h3 id="coding-task-2">Coding Task 2</h3><p>Your task here is to add some important functionality to the interpreter. Namely, you will complete the implementations of the following functions:</p><ul><li><code class="language-plaintext highlighter-rouge">istore/iload</code></li><li><code class="language-plaintext highlighter-rouge">istore_&lt;n&gt;/iload_&lt;n&gt;</code></li><li><code class="language-plaintext highlighter-rouge">iadd</code></li><li><code class="language-plaintext highlighter-rouge">imul</code></li><li><code class="language-plaintext highlighter-rouge">idiv</code></li><li><code class="language-plaintext highlighter-rouge">irem</code></li><li><code class="language-plaintext highlighter-rouge">isub</code></li><li><code class="language-plaintext highlighter-rouge">ineg</code></li><li><code class="language-plaintext highlighter-rouge">new</code></li><li><code class="language-plaintext highlighter-rouge">newarray</code></li><li><code class="language-plaintext highlighter-rouge">arraylength</code></li></ul><p>You should use the <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5%22">Java ISA reference</a> to complete the implementation of these instructions. I will not give you much more information here, but some existing support functions in the Hawkbeans codebase that you will want to leverage include:</p><ul><li><code class="language-plaintext highlighter-rouge">push_val()</code> and <code class="language-plaintext highlighter-rouge">pop_val()</code> functions. These are used to manipulate the current frame’s operand stack. <code class="language-plaintext highlighter-rouge">hb_resolve_class()</code> you will need for new.</li><li><code class="language-plaintext highlighter-rouge">gc_obj_alloc</code> you will also need for new</li><li>You will need <code class="language-plaintext highlighter-rouge">gc_array_alloc()</code> for <code class="language-plaintext highlighter-rouge">newarray</code></li></ul><p>Note within <code class="language-plaintext highlighter-rouge">bc_interp.c</code> you can access the current stack frame using <code class="language-plaintext highlighter-rouge">cur_thread-&gt;cur_frame</code>. <code class="language-plaintext highlighter-rouge">cur_thread</code> is a globally scoped pointer that refers to the currently executing thread (remember, there is only one at this point).</p><p>Note that in some cases you might need to look at the C structure representing a Java object. This is the <code class="language-plaintext highlighter-rouge">native_obj_t</code> defined in <code class="language-plaintext highlighter-rouge">include/class.h</code>. You will need this at least for <code class="language-plaintext highlighter-rouge">arraylength</code>.</p><p>One pitfall to avoid here is to be very careful with the types used by the elements in a <code class="language-plaintext highlighter-rouge">var_t</code> (defined in <code class="language-plaintext highlighter-rouge">include/class.h</code>). For example, you may have code like:</p><pre><code class="language-C">var_t x;
x.int_val = 1;
x.int_val = -x.int_val;
</code></pre><p>This is actually a bug. The result will actually end up being interpreted as <code class="language-plaintext highlighter-rouge">0xffffffff</code> instead of just <code class="language-plaintext highlighter-rouge">-1</code> since the <code class="language-plaintext highlighter-rouge">int_val</code> element of a <code class="language-plaintext highlighter-rouge">var_t</code> is actually defined as an unsigned type (for various reasons dealing with class loading). Be careful of this when writing your integer arithmetic routines!</p><p>Some of the required actions for these instructions have similarities that might point towards using macros to avoid repeating code (see <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>.</p><h2 id="part-5-exceptions">Part 5: Exceptions</h2><p>No JVM is complete without exceptions. If you’ve ever had to write complex error handling code in C using gotos and labels, you will appreciate just how powerful the abstraction of software exceptions is. In this part, you will add exception support to Hawkbeans. There is a skeleton in place for you; you must just fill in the exception interface and the missing usage of it in the bytecode interpreter.</p><h3 id="coding-task-3">Coding Task 3</h3><p>The interface to exceptions used by the rest of the JVM is defined in <code class="language-plaintext highlighter-rouge">include/exceptions.h</code>. The two main functions are:</p><ul><li><code class="language-plaintext highlighter-rouge">hb_throw_exception()</code>: Used to throw an exception given a reference to an existing <code class="language-plaintext highlighter-rouge">Exception</code> object (which ultimately derives from the <code class="language-plaintext highlighter-rouge">Throwable</code> class). This is the function used by the JVM when a programmer explicitly throws an exception (see <code class="language-plaintext highlighter-rouge">testcode/TestNullPointerThrow.java</code>). This ultimately turns into the execution of the athrow bytecode instruction (which you will also implement).</li><li><code class="language-plaintext highlighter-rouge">hb_throw_and_create_excp()</code>: Used to throw an exception without an object reference. This is used when the JVM throws exceptions indirectly caused by the execution of some instruction. For example, if an access to an array element with an index past the length of an array is attempted, the JVM would invoke this method with the <code class="language-plaintext highlighter-rouge">EXCP_NULL_PTR</code> argument (defined in <code class="language-plaintext highlighter-rouge">include/exceptions.h</code>).</li></ul><p>Your task here is to implement <code class="language-plaintext highlighter-rouge">hb_throw_exception()</code> and <code class="language-plaintext highlighter-rouge">hb_throw_and_create_excp()</code> in <code class="language-plaintext highlighter-rouge">jvm/exceptions.c</code>, as well as the handler for the athrow instruction in <code class="language-plaintext highlighter-rouge">jvm/bc_interp.c</code>.</p><p>I’m not going to give you too much instruction here, but the general principle is that you need to scan the exception table for the method corresponding to the current frame and look for a matching exception entry. If the entry is found, we invoke the handler for that entry. If not, we pop a frame and continue searching. If we reach the base frame and still have not found a matching exception table entry, it means that no method explicitly provided a handler for the exception that was thrown, so we must kill the current thread and exit. You can expect that if the current code (which threw the exception) has a catch clause somewhere, you should be finding its exception table within the scope of that method!</p><p>You should look at the documentation for <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.10">exceptions</a> and the documentation for <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.athrow"><code class="language-plaintext highlighter-rouge">athrow</code></a> to complete your implementation.</p><p>Note, you’ll want to look at and leverage these functions which already exist:</p><ul><li><code class="language-plaintext highlighter-rouge">hb_get_or_load_class()</code></li><li><code class="language-plaintext highlighter-rouge">gc_obj_alloc()</code></li><li><code class="language-plaintext highlighter-rouge">hb_invoke_ctor()</code></li><li><code class="language-plaintext highlighter-rouge">hb_get_class_name()</code></li><li><code class="language-plaintext highlighter-rouge">hb_pop_frame()</code></li><li><code class="language-plaintext highlighter-rouge">hb_get_super_class()</code></li><li><code class="language-plaintext highlighter-rouge">hb_resolve_class()</code></li><li><code class="language-plaintext highlighter-rouge">get_excp_str()</code></li></ul><p>You’ll notice that I’ve given you less help in terms of skeleton code here. This is intentional. Reading the documentation is your best bet here. You’ll probably want to break down your implementation into several support functions that handle each subtask of exception throwing rather than trying to throw it all into one function.</p><h2 id="part-6-garbage-collection">Part 6: Garbage Collection</h2><p>With the current state of Hawkbeans, if you were to write a Java program that created many objects or arrays, you would see an <code class="language-plaintext highlighter-rouge">OutOfMemoryException</code> thrown pretty quickly. This is mostly because the default heap size is so small. But also because in Java, there’s no way to explicitly <code class="language-plaintext highlighter-rouge">free()</code> objects that we’ve allocated. This is because the JVM spec requires that there be some automatic memory management component present in the JVM, i.e. a garbage collector.</p><p>The interesting thing is that the JVM spec does not give <em>any</em> prescriptions on the nature of the GC, only that it must be <em>present</em>. Therefore, we have significant flexibility when implementing our GC. For this part, I will describe a simple GC scheme which you will implement.</p><p>You will implement a precise garbage collector using the simple but effective Mark-and-Sweep algorithm which we discussed in class. Recall that a precise collector knows what a reference looks like vs. some other primitive data type. If we don’t have this information, GC becomes a bit harder because we have to figure out which things are references and which are not. For example, everything we’re interested in scanning for GC in Hawkbeans will be a <code class="language-plaintext highlighter-rouge">var_t</code>. Our goal is to figure out whether a given <code class="language-plaintext highlighter-rouge">var_t</code> is a reference or just some primitive type, e.g., an <code class="language-plaintext highlighter-rouge">int</code>. It is not enough just to look at the bits to tell the difference. One strategy is that we could add some information to a <code class="language-plaintext highlighter-rouge">var_t</code> which would tag the type. This takes up more memory, however, and complicates the rest of the JVM. We will use a different strategy.</p><p>Our GC will use a <em>reference table</em> to track live object references in the JVM. This is essentially a hash table which uses the address of a reference as its key. When objects are allocated, and new references to them are created, those references will be inserted into this hashtable. The GC is invoked periodically by the bytecode interpreter after a predetermined amount of time has passed. When the GC is invoked, a set of root objects are scanned. The GC must look at every variable in each root object and check if it exists in the reference table. If it does, it will mark the object the reference refers to as <strong>live</strong> and will then scan that object for more references. This process continues until no more references are found. This is essentially the <em>mark</em> phase of the GC algorithm.</p><p>After all root objects have been traversed, the <em>sweep</em> phase will iterate through the reference table, and see which references were still around during the mark phase. Those which were not are now considered garbage and must be collected. The details are discussed below.</p><h3 id="coding-task-4">Coding Task 4</h3><p>There is significantly more skeleton code for you to work with for this part. You should start by taking a look at <code class="language-plaintext highlighter-rouge">gc_init()</code> in <code class="language-plaintext highlighter-rouge">jvm/gc.c</code>. This is where the GC is initialized. The important bits here that you should look at are the calls to <code class="language-plaintext highlighter-rouge">add_root()</code> and <code class="language-plaintext highlighter-rouge">init_ref_tbl()</code>. Each call to <code class="language-plaintext highlighter-rouge">add_root()</code> is registering a root object which the GC shall scan during the mark phase. Each root is associated with a callback function for scanning that particular root. Your job will be to implement these scanning functions. The framework for them is there, you only need fill them in.</p><p>Here are the important roots:</p><ul><li>The base object (this is the instantiated object corresponding to the class that was provided at the command line): You must scan all of the fields of this object for references and any reference you find, you must then descend into the object referred to by that reference and scan its fields as well.</li><li>The base object reference: This is the reference to the above object. Because it was created before the GC was initialized, it must be special cased. The code for scanning this reference is already implemented.</li><li>The class map: you must scan all classes loaded into the class map, and check their static fields for references. Recall these fields are those which are the same for every instance of the class, so you cannot access them from a given object instance. You can find them in the <code class="language-plaintext highlighter-rouge">field_vals</code> of a <code class="language-plaintext highlighter-rouge">java_class_t</code> structure.</li><li>The base frame: This is the frame corresponding to the main function invoked at the beginning of the JVM’s execution. This frame’s local variables and operand stack are scanned for references to objects just like before. Each successive frame must also be scanned.</li></ul><p>Note that the framework for invoking the scanning functions is already in place (see <code class="language-plaintext highlighter-rouge">gc_collect()</code>, <code class="language-plaintext highlighter-rouge">mark()</code>, and <code class="language-plaintext highlighter-rouge">scan_roots()</code>).</p><h5 id="mark">Mark</h5><p>You must first finish the following functions:</p><ul><li><code class="language-plaintext highlighter-rouge">scan_base_obj()</code></li><li><code class="language-plaintext highlighter-rouge">scan_base_frame()</code></li><li><code class="language-plaintext highlighter-rouge">scan_class_map()</code></li></ul><p>Note that the mark phase first sets every entry in the ref table to the state <code class="language-plaintext highlighter-rouge">GC_REF_ABSENT</code> in the <code class="language-plaintext highlighter-rouge">clear_ref_tbl()</code> function. That way reference that are not live will be in that state. When you scan your roots, you should set any references you find to the state <code class="language-plaintext highlighter-rouge">GC_REF_PRESENT</code> using the <code class="language-plaintext highlighter-rouge">mark_ref()</code> function. You can determine that a variable is indeed a reference using the <code class="language-plaintext highlighter-rouge">is_valid_ref()</code> function.</p><p>One programming idiom you will see here that you might not recognize is the pattern involving opaque pointers and callback functions. The <code class="language-plaintext highlighter-rouge">scan_X</code> functions are considered callbacks because we pass them as function pointers to the <code class="language-plaintext highlighter-rouge">add_roots()</code> registration function at initialization time. When the GC is invoked, it will call each of these functions in turn. This pattern makes it easy to add other GC roots later on if we want. See how each of the functions above each takes a <code class="language-plaintext highlighter-rouge">void * priv_data</code> as an argument. This is there so that when the callback function is invoked, it can re-derive whatever state it needs from that pointer. This state is passed in during callback registration (<code class="language-plaintext highlighter-rouge">add_root()</code>). You can see that each callback will be given a pointer to the GC’s state, i.e., a <code class="language-plaintext highlighter-rouge">gc_state_t</code> pointer.</p><h5 id="sweep">Sweep</h5><p>You now must complete the sweep phase of the collector. This means you must fill in the <code class="language-plaintext highlighter-rouge">sweep()</code> function. This function must iterate through the reference table (see an example of how to do this in <code class="language-plaintext highlighter-rouge">clear_ref_tbl()</code>) and collect all entries whose status is set to <code class="language-plaintext highlighter-rouge">GC_REF_ABSENT</code>. To collect an object, you must first free the reference table entry for it, then you must free the object using the memory allocator’s <code class="language-plaintext highlighter-rouge">object_free()</code> function. Make sure to update the collectors stats (namely <code class="language-plaintext highlighter-rouge">obj_collected</code> and <code class="language-plaintext highlighter-rouge">bytes_reclaimed</code>). Finally, after the object has been freed, you should <code class="language-plaintext highlighter-rouge">free()</code> the reference itself.</p><h2 id="testing-and-debugging">Testing and Debugging</h2><p>This is a big enough codebase to work with that there’s really no way to make progress without testing. You should be testing your code frequently, and even add your own tests. For example, for each instruction that you add in <a href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/#part-4-bytecode-interpretation">Part 4</a>, you should write a Java test program to make sure it works. This may be difficult for <a href="https://khale.github.io/iit-cs562-s24-site/projects/03-hawkbeans/#part-3-symbolic-resolution-linking">Part 3</a> since there are a lot of moving parts. Your best bet there is to add a lot of debugging prints (using <code class="language-plaintext highlighter-rouge">HB_DEBUG()</code>) to get an idea of what the JVM is doing. To compile a new Java program, you’ll have to make sure you have the JDK 1.8 environment installed. Once you do, you can compile a Java program by running:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javac <span class="nt">-g</span> MyProgram.java
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">-g</code> flag here tells the Java compiler to add debugging information like line numbers and local variable names to the class binary. <strong>Don’t forget that the class name in your program must match the filename</strong>.</p><p>You’ll also probably want to get familiar with class file dumps. Probably the most informative is:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javap <span class="nt">-v</span> ClassFile
</code></pre></div></div><p>This dumps out pretty much everything in the class file, including the constant pool items, class methods (including constructors and class initializers), and static and instance fields.</p><p>To enable debugging prints within the Hawkbeans JVM, you can pass environment variables to the compiler just like you did with Hawknest, only you can do so at a finer granularity here. If you’d like to see general debugging prints, set <code class="language-plaintext highlighter-rouge">MODE=DEBUG</code> when invoking <code class="language-plaintext highlighter-rouge">make</code>. You can then set the remaining flags depending on which component of the JVM you’d like to debug. For example, if I’m working in my bytecode interpreter and I want to enable debugging there, I’d set <code class="language-plaintext highlighter-rouge">DEBUG_INTERP</code> to 1, then in my code in <code class="language-plaintext highlighter-rouge">jvm/bc_interp.c</code> I’d use the <code class="language-plaintext highlighter-rouge">BC_DEBUG()</code> print macro to add debugging printouts specific to that component. These prints will only appear when debugging is enabled. You can take a look at the <code class="language-plaintext highlighter-rouge">Makefile</code> (see <code class="language-plaintext highlighter-rouge">CC_DEBUG_DEFINES</code>) to see which subsystems have component-specific debugging prints.</p><h3 id="the-hawkbeans-debugger">The Hawkbeans Debugger</h3><p>I’ve added a line-oriented debugger much like you used in Hawknest for Hawkbeans. This will allow you to step through a Java program, set breakpoints, dump state etc. It isn’t complete, but it should help you to find problems. Just like with Hawknest, start Hawkbeans with the <code class="language-plaintext highlighter-rouge">-i</code> option to drop immediately into the debugger shell. Type <code class="language-plaintext highlighter-rouge">help</code> at that shell to see what commands you can invoke. Note that these are inspired by both <code class="language-plaintext highlighter-rouge">gdb</code> and <code class="language-plaintext highlighter-rouge">jdb</code>, the Java debugger that ships with OpenJDK.</p><h2 id="getting-help">Getting Help</h2><p>If you’re having trouble, do not hesitate to get help. Your first bet is to come to office hours or post to the class Discord. If you need to set up an appointment for help, I will do my best to accommodate you.</p><h2 id="extra-credit">Extra Credit</h2><ul><li>Port Hawkbeans to Hawknest (i.e., run the JVM on the 6502)</li><li>Complete implementation of the bytecode interpreter</li><li>Adding proper access/permission checking in class loading</li><li>Adding support for reflection</li><li>Adding support for actually native libraries (currently, only a few native functions are supported, and are special-cased. You can see how this works in <code class="language-plaintext highlighter-rouge">jvm/native.c</code>)</li><li>Add a JIT compiler (e.g., a profiling or tracing JIT)</li><li>Add support for multiple threads and concurrent execution (and possibly parallel execution using pthreads)</li><li>Add more system support, e.g., for file I/O and networking</li><li>Add support for user-defined class loaders</li><li>Add support for random numbers</li><li>Add sufficient support to the JVM and standard libraries to support lambda expressions (a relatively new feature in Javaland)</li></ul><h2 id="hand-in">Hand-In</h2><p>You will hand in your code to me, as in the previous project, using our handin script. Your code will be graded based primarily on how well it executes a series of Java tests of my choosing. A small portion of your grade will be determined by the cleanliness, style, and documentation of your code. I will definitely penalize you if your code is poorly structured and not broken down cleanly using abstraction and modularity.</p><p>Make sure to commit often. Your commits should encapsulate some logical component that you added to the codebase. For example, once I complete my implementation of <code class="language-plaintext highlighter-rouge">iadd</code>, I would create a commit for that. Make sure your commit messages are sane and describe succinctly the nature of the additions.</p><p>Once you’ve finished, you can can hand in your code using our scripts. Only one person from each group should submit a handin.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make handin
</code></pre></div></div><hr><footer><p class="text-small text-grey-dk-100 mb-0">Kyle C. Hale © 2024 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></p></footer></div></div><div class="search-overlay"></div></div><script type="text/javascript" src="./Project 2 _ CS 562_files/toggle_mode.js"></script>
<div id="teal-job-tracker-root-stable" style="z-index: 2147483647;"><iframe id="teal-job-tracker-iframe-stable" style="background: rgb(255, 255, 255) !important; width: 380px !important; height: 100vh !important; position: fixed !important; inset: 0px -380px auto auto !important; z-index: 2147483647 !important; border: 0px !important; box-shadow: rgba(0, 0, 0, 0.25) 0px 0px 16px -3px !important; transition: right 0.25s ease-in-out !important; transform: none !important;" src="./Project 2 _ CS 562_files/saved_resource.html"></iframe></div><div id="teal-job-tracker-companion-root-stable" style="display: block; z-index: 2147483646; bottom: 58px; right: 0px; position: fixed; height: 60px; width: auto;"></div></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>